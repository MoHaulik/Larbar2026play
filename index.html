<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>LærbarXR Quest Player</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    :root {
      --primary: #0969da;
      --primary-hover: #0855b3;
      --bg: #f3f4f6;
      --card-bg: rgba(255, 255, 255, 0.95);
      --text: #1f2937;
      --text-muted: #6b7280;
    }
    
    body { 
      margin: 0; 
      overflow: hidden; 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; 
      background: var(--bg); 
      color: var(--text);
    }

    #overlay { 
      position: absolute; 
      top: 0; 
      left: 0; 
      width: 100%; 
      height: 100%; 
      display: flex; 
      flex-direction: column; 
      justify-content: center; 
      align-items: center; 
      z-index: 9000;
      padding: 20px;
      box-sizing: border-box;
      background: radial-gradient(circle at center, #e5e7eb 0%, #9ca3af 100%);
    }

    .card {
      background: var(--card-bg);
      border-radius: 20px;
      padding: 32px 40px;
      box-shadow: 0 20px 40px rgba(0,0,0,0.15);
      max-width: 440px;
      width: 100%;
      text-align: center;
      backdrop-filter: blur(10px);
    }

    .logo-container {
      margin-bottom: 24px;
    }

    h1 {
      margin: 0 0 8px 0;
      font-size: 28px;
      font-weight: 700;
      letter-spacing: -0.5px;
    }

    p.subtitle {
      margin: 0 0 28px 0;
      color: var(--text-muted);
      font-size: 15px;
    }

    .file-drop-area {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 32px 20px;
      border: 2px dashed #cbd5e1;
      border-radius: 16px;
      background: #f8fafc;
      cursor: pointer;
      transition: all 0.2s;
      margin-bottom: 20px;
    }

    .file-drop-area:hover {
      border-color: var(--primary);
      background: #f0f7ff;
    }

    .file-drop-area span {
      font-size: 16px;
      font-weight: 600;
      color: var(--primary);
    }
    
    .file-drop-area small {
      color: var(--text-muted);
      margin-top: 8px;
    }

    #file-input { 
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      opacity: 0;
      cursor: pointer;
    }

    #session-info {
      font-size: 16px;
      color: #059669;
      margin-bottom: 24px;
      font-weight: 600;
      min-height: 24px;
      background: #ecfdf5;
      padding: 12px;
      border-radius: 8px;
      display: none;
    }
    #session-info.show { display: block; }

    #start-button { 
      padding: 16px 32px; 
      font-size: 18px; 
      background: var(--primary); 
      color: white; 
      border: none; 
      border-radius: 12px; 
      box-shadow: 0 4px 12px rgba(9, 105, 218, 0.3); 
      cursor: pointer; 
      transition: all 0.2s; 
      font-weight: 600;
      width: 100%;
    }

    #start-button:hover:not(:disabled) { 
      transform: translateY(-2px); 
      background: var(--primary-hover);
      box-shadow: 0 6px 16px rgba(9, 105, 218, 0.4);
    }

    #start-button:disabled {
      background: #e2e8f0;
      color: #94a3b8;
      cursor: not-allowed;
      box-shadow: none;
    }

    #status { 
      position: fixed; 
      bottom: 40px; 
      left: 50%; 
      transform: translateX(-50%); 
      background: rgba(17, 24, 39, 0.9); 
      color: white; 
      padding: 14px 28px; 
      border-radius: 30px; 
      font-size: 15px; 
      font-weight: 500; 
      display: none; 
      z-index: 9999; 
      backdrop-filter: blur(4px);
    }

    .exit-xr { 
      position: fixed; 
      top: 24px; 
      right: 24px; 
      background: rgba(255,255,255,0.9); 
      color: #111; 
      border: none; 
      border-radius: 50%; 
      width: 50px; 
      height: 50px; 
      display: none; 
      align-items: center; 
      justify-content: center; 
      font-size: 28px; 
      cursor: pointer; 
      z-index: 9999;
      font-weight: 300;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }

    .xr-active .exit-xr { display: flex; }
    .xr-active #overlay { display: none; }
    video { display: none; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.module.js" type="module"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</head>
<body>
  <video id="video" playsinline crossorigin="anonymous"></video>

  <div id="overlay">
    <div class="card">
      <div class="logo-container">
        <h1>LærbarXR Player</h1>
        <p class="subtitle">Immersive Gaze-Controlled Training</p>
      </div>
      
      <div class="file-drop-area">
        <span>Click to Upload Scenario</span>
        <small>.zip or .lxr packages</small>
        <input type="file" id="file-input" accept=".zip,.lxr">
      </div>
      
      <div id="session-info"></div>
      
      <button id="start-button" disabled>Enter Immersive VR</button>
    </div>
  </div>

  <button class="exit-xr" id="exit-xr" aria-label="Exit VR">×</button>
  <div id="status"></div>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.module.js';

    // Core 3D Variables
    let camera, scene, renderer, xrSession = null;
    let videoElement, videoTexture, videoMaterial, videoMesh;
    let fallbackEnvironment;
    
    // Interactions (Strictly Gaze)
    let raycaster, reticle, clock;
    
    // Logic State
    let gazeTimer = 0;
    let lastIntersectedChoice = null;
    const GAZE_TIME_THRESHOLD = 2.0; 
    let sessionData = null;
    let assetCache = {};
    let currentNode = null;
    let nodeTimer = 0;
    let activeChoices = []; 
    let overlaysGroup = new THREE.Group();

    // Analytics
    let sessionLog = [];
    let sessionStartTime = 0;

    // UI Elements
    const startButton = document.getElementById('start-button');
    const fileInput = document.getElementById('file-input');
    const sessionInfo = document.getElementById('session-info');
    const statusElement = document.getElementById('status');
    const exitButton = document.getElementById('exit-xr');

    function init() {
      // Scene Setup
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x111111);
      
      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 100);
      scene.add(camera);
      
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      document.body.appendChild(renderer.domElement);
      
      clock = new THREE.Clock();
      raycaster = new THREE.Raycaster();

      // Fallback Environment (When no video is playing)
      const envGeo = new THREE.SphereGeometry(20, 32, 32);
      const envMat = new THREE.MeshBasicMaterial({ color: 0x1f2937, wireframe: true, transparent: true, opacity: 0.1 });
      fallbackEnvironment = new THREE.Mesh(envGeo, envMat);
      scene.add(fallbackEnvironment);
      
      // Video Setup
      videoElement = document.getElementById('video');
      videoTexture = new THREE.VideoTexture(videoElement);
      videoTexture.minFilter = THREE.LinearFilter;
      videoTexture.magFilter = THREE.LinearFilter;
      videoTexture.format = THREE.RGBAFormat;
      
      const sphereGeometry360 = new THREE.SphereGeometry(15, 64, 32, 0, Math.PI * 2, 0, Math.PI);
      sphereGeometry360.scale(-1, 1, 1); 
      videoMaterial = new THREE.MeshBasicMaterial({ map: videoTexture, side: THREE.FrontSide });
      videoMesh = new THREE.Mesh(sphereGeometry360, videoMaterial);
      videoMesh.rotation.y = 0; // Align forward
      videoMesh.visible = false;
      scene.add(videoMesh);
      
      scene.add(overlaysGroup);

      setupGazeInteraction();

      window.addEventListener('resize', onWindowResize);
      startButton.addEventListener('click', startXR);
      exitButton.addEventListener('click', () => { if (xrSession) xrSession.end(); });
      fileInput.addEventListener('change', handleFileSelect);
    }

    function setupGazeInteraction() {
      // Gaze Reticle (Attached directly to the camera view)
      const reticleGeo = new THREE.RingGeometry(0.015, 0.02, 32);
      const reticleMat = new THREE.MeshBasicMaterial({ color: 0xffffff, opacity: 0.7, transparent: true, side: THREE.DoubleSide });
      reticle = new THREE.Mesh(reticleGeo, reticleMat);
      
      const gazeProgressGeo = new THREE.CircleGeometry(0.015, 32);
      // Prominent blue fill when gazing
      const gazeProgressMat = new THREE.MeshBasicMaterial({ color: 0x0969da, opacity: 0.9, transparent: true, side: THREE.DoubleSide });
      const gazeProgress = new THREE.Mesh(gazeProgressGeo, gazeProgressMat);
      gazeProgress.name = 'gazeProgress';
      gazeProgress.scale.set(0, 0, 0);
      
      reticle.add(gazeProgress);
      // Positioned exactly 1 meter in front of the user's face
      reticle.position.z = -1;
      camera.add(reticle);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    // === Data & File Loading ===
    async function handleFileSelect(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      sessionInfo.textContent = 'Loading scenario packages...';
      sessionInfo.classList.add('show');
      startButton.disabled = true;
      sessionData = null;
      
      // Cleanup previous memory
      Object.keys(assetCache).forEach(url => URL.revokeObjectURL(url));
      assetCache = {};

      try {
        const zip = await JSZip.loadAsync(file);
        const projectFile = zip.file('project.json');
        
        if (projectFile) {
            // New Builder Structure
            const projectData = await projectFile.async('string');
            sessionData = JSON.parse(projectData);

            const assetPromises = [];
            if (sessionData.assets.videos) {
                sessionData.assets.videos.forEach(v => {
                    const f = zip.file(v.file);
                    if (f) assetPromises.push(f.async('blob').then(b => assetCache[v.id] = URL.createObjectURL(b)));
                });
            }
            if (sessionData.assets.images) {
                sessionData.assets.images.forEach(img => {
                    const f = zip.file(img.file);
                    if (f) assetPromises.push(f.async('blob').then(b => assetCache[img.id] = URL.createObjectURL(b)));
                });
            }
            await Promise.all(assetPromises);
        } else {
            // Legacy Structure fallback
            const htmlFile = zip.file('index.html');
            if (!htmlFile) throw new Error('project.json not found in zip.');
            const htmlContent = await htmlFile.async('string');
            const match = htmlContent.match(/const\s+flow\s*=\s*(\{[\s\S]*?\});/);
            if (!match) throw new Error('Legacy format unreadable.');
            sessionData = (new Function(`return ${match[1]}`))();
            
            const assetPromises = [];
            zip.folder('assets').forEach((rel, zipEntry) => {
                assetPromises.push(zipEntry.async('blob').then(b => assetCache[zipEntry.name.split('/').pop()] = URL.createObjectURL(b)));
            });
            await Promise.all(assetPromises);
        }

        if (!sessionData || !sessionData.nodes || !sessionData.startNode) {
            throw new Error('Invalid project structure.');
        }

        sessionInfo.textContent = `Ready: ${sessionData.title}`;
        startButton.disabled = false;
        updateStatus('Scenario loaded successfully!');

      } catch (err) {
        console.error('Failed to load:', err);
        sessionInfo.textContent = 'Error parsing file.';
        updateStatus(`Error: ${err.message}`, true);
      }
    }
    
    // === Immersive XR Lifecycle ===
    function startXR() {
      if (!sessionData) return;
      
      navigator.xr.requestSession('immersive-vr', {
        optionalFeatures: ['local-floor']
      })
      .then(onSessionStarted)
      .catch(err => updateStatus(`Failed to start VR: ${err.message}`, true));
    }
    
    function onSessionStarted(session) {
      xrSession = session;
      document.body.classList.add('xr-active');
      renderer.xr.setReferenceSpaceType('local');
      renderer.xr.setSession(session);
      renderer.setAnimationLoop(render);
      session.addEventListener('end', onSessionEnd);
      
      sessionStartTime = performance.now();
      sessionLog = [{ action: 'session_start', title: sessionData.title, timestamp: sessionStartTime }];
      
      currentNode = sessionData.nodes.find(n => n.id === sessionData.startNode);
      if (currentNode) {
        loadNode(currentNode);
      } else {
        updateStatus('Error: Start node not found.', true);
        session.end();
      }
    }

    function onSessionEnd() {
      document.body.classList.remove('xr-active');
      renderer.setAnimationLoop(null);
      xrSession = null;
      videoElement.pause();
      videoElement.src = '';
      clearOverlays();
      
      // Automatic Evaluation Download
      if (sessionLog.length > 1) {
        sessionLog.push({ action: 'session_end', duration_sec: (performance.now() - sessionStartTime) / 1000 });
        try {
          const reportData = JSON.stringify(sessionLog, null, 2);
          const blob = new Blob([reportData], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `${sessionData.title.replace(/[^a-z0-9]/gi, '_')}_eval.json`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
        } catch (err) {}
      }
      
      sessionLog = [];
      sessionStartTime = 0;
      currentNode = null;
    }
    
    // === Node Logic ===
    async function loadNode(node) {
      sessionLog.push({ action: 'node_start', node_id: node.id, title: node.title, timestamp: performance.now() });
      clearOverlays();
      nodeTimer = 0;
      window.isTransitioning = false;

      // Handle Video
      videoElement.pause();
      videoMesh.visible = false;
      if (node.video) {
        let videoSrc = assetCache[node.video]; 
        if (!videoSrc && sessionData.assets.videos) {
            const videoAsset = sessionData.assets.videos.find(v => v.id === node.video);
            if (videoAsset) videoSrc = assetCache[videoAsset.id] || assetCache[videoAsset.name];
        }
        if (videoSrc) {
          videoElement.src = videoSrc;
          videoElement.loop = false; 
          videoElement.play().catch(e => console.warn("Video autoplay blocked", e));
          videoMesh.visible = true;
        }
      }

      // Load Image Overlays
      if (node.imageOverlays) {
          for (const io of node.imageOverlays) {
              if (!io.imageId || !assetCache[io.imageId]) continue;
              const mesh = await createImagePlane(assetCache[io.imageId], { scale: io.scale || 1 });
              if (mesh) {
                  positionMeshFromXY(mesh, io.x, io.y, 7.5); // slightly inside video sphere
                  mesh.userData = { startTime: io.time || 0, endTime: (io.time || 0) + (io.duration || 5), isOverlay: true };
                  mesh.visible = false; 
                  overlaysGroup.add(mesh);
              }
          }
      }

      // Load Text Overlays
      if (node.textOverlays) {
          for (const to of node.textOverlays) {
              const textMesh = createTextPlane(to.text || '', { 
                  backgroundColor: to.color || 'rgba(255, 255, 255, 0.95)', 
                  textColor: to.textColor || 'black', 
                  scale: to.scale || 1 
              });
              positionMeshFromXY(textMesh, to.x, to.y, 7);
              textMesh.userData = { startTime: to.time || 0, endTime: (to.time || 0) + (to.duration || 3), isOverlay: true };
              textMesh.visible = false;
              overlaysGroup.add(textMesh);
          }
      }

      // Load Question & Choices
      if (node.question || (node.choices && node.choices.length > 0)) {
          const qGroup = new THREE.Group();
          let yOffset = 0;
          const scale = node.questionScale || 1;

          if (node.question) {
              const qMesh = createTextPlane(node.question, { 
                  width: 1024, height: 256, fontSize: 50,
                  backgroundColor: 'rgba(17, 24, 39, 0.9)', textColor: 'white', 
                  fontWeight: '700', scale: scale 
              });
              qMesh.position.set(0, yOffset, 0);
              qGroup.add(qMesh);
              yOffset -= (0.8 * scale);
          }

          if (node.choices && node.choices.length > 0) {
              node.choices.forEach((choice) => {
                  const cMesh = createTextPlane(choice.label, { 
                      width: 800, height: 160, fontSize: 44,
                      backgroundColor: 'rgba(9, 105, 218, 0.95)', textColor: 'white', 
                      scale: scale * 0.8 
                  });
                  cMesh.position.set(0, yOffset, 0);
                  cMesh.userData = { isChoice: true, choiceData: choice };
                  qGroup.add(cMesh);
                  activeChoices.push(cMesh);
                  yOffset -= (0.5 * scale);
              });
          }

          positionMeshFromXY(qGroup, node.questionX || 50, node.questionY || 50, 6.5);
          qGroup.userData = { startTime: node.questionTime || 0, endTime: Infinity, isOverlay: true };
          qGroup.visible = false;
          overlaysGroup.add(qGroup);
      }
    }

    // Coordinates mapper (Flat 2D UI to 360 Sphere)
    function positionMeshFromXY(mesh, pctX, pctY, radius) {
        pctX = pctX !== undefined ? pctX : 50;
        pctY = pctY !== undefined ? pctY : 50;
        const yaw = (pctX - 50) / 100 * (Math.PI * 2); 
        const pitch = (50 - pctY) / 100 * Math.PI; 
        mesh.position.set(
            radius * Math.sin(yaw) * Math.cos(pitch),
            radius * Math.sin(pitch),
            -radius * Math.cos(yaw) * Math.cos(pitch)
        );
        mesh.lookAt(0, 0, 0); 
    }
    
    // === Selection Logic ===
    function selectChoice(choice) {
      if(window.isTransitioning) return;
      window.isTransitioning = true;
      
      sessionLog.push({
        action: 'choice_made', node: currentNode.id, choice: choice.label,
        correct: choice.correct, target: choice.target, time: performance.now()
      });
      
      updateGazeProgress(0); // Reset UI
      
      let nextNodeId = choice.target || currentNode.defaultNext;
      if (nextNodeId) {
        const nextNode = sessionData.nodes.find(n => n.id === nextNodeId);
        if (nextNode) {
          if (nextNode.type === 'end') { loadNode(nextNode); setTimeout(endSession, 3000); } 
          else { currentNode = nextNode; loadNode(currentNode); }
        } else {
          endSession();
        }
      } else {
        endSession();
      }
    }
    
    function endSession() {
      if (xrSession) xrSession.end();
    }

    // === Render & Interaction Loop ===
    function render(timestamp, frame) {
      const dt = clock.getDelta();
      
      let currentTime = 0;
      if (currentNode) {
          if (currentNode.video && videoElement && videoElement.readyState > 0) {
              currentTime = videoElement.currentTime;
              
              // Auto-Navigate if video ends naturally without user choices
              if (videoElement.ended && currentNode.defaultNext && activeChoices.length === 0) {
                  selectChoice({ label: 'auto-nav', target: currentNode.defaultNext });
              }
          } else {
              // Timer for nodes with just images/text
              nodeTimer += dt;
              currentTime = nodeTimer;
              if (currentNode.defaultNext && activeChoices.length === 0 && currentTime >= (currentNode.duration || 10)) {
                  selectChoice({ label: 'auto-nav-timer', target: currentNode.defaultNext });
              }
          }

          // Toggle Overlay Visibilities based on timeline
          overlaysGroup.children.forEach(child => {
              if (child.userData.isOverlay && child.userData.startTime !== undefined) {
                  child.visible = currentTime >= child.userData.startTime && currentTime <= child.userData.endTime;
              }
          });
      }

      handleGazeInteractions(dt);
      
      // Gentle spin for fallback environment
      fallbackEnvironment.rotation.y += dt * 0.05;

      renderer.render(scene, camera);
    }

    function getVisibleChoices() {
        return activeChoices.filter(c => c.visible && (c.parent ? c.parent.visible : true));
    }

    function handleGazeInteractions(dt) {
      const visibleChoices = getVisibleChoices();
      
      // Shoot ray directly from center of the camera
      raycaster.setFromCamera({ x: 0, y: 0 }, camera);
      const intersects = raycaster.intersectObjects(visibleChoices, false);

      let intersectedChoice = null;
      if (intersects.length > 0) {
          intersectedChoice = intersects[0].object;
      }

      // Handle the intersected mesh hover/timer logic
      if (intersectedChoice) {
        if (lastIntersectedChoice === intersectedChoice) {
          gazeTimer = Math.min(GAZE_TIME_THRESHOLD, gazeTimer + dt);
          if (gazeTimer >= GAZE_TIME_THRESHOLD) {
            selectChoice(intersectedChoice.userData.choiceData);
          }
        } else {
          gazeTimer = 0;
          lastIntersectedChoice = intersectedChoice;
        }
        updateGazeProgress(gazeTimer / GAZE_TIME_THRESHOLD, intersectedChoice);
      } else {
        gazeTimer = 0;
        lastIntersectedChoice = null;
        updateGazeProgress(0);
      }
    }

    function updateGazeProgress(progress, targetMesh = null) {
      const progressIndicator = reticle.getObjectByName('gazeProgress');
      if (progressIndicator) {
        const scale = Math.max(0.001, Math.min(1, progress));
        progressIndicator.scale.set(scale, scale, scale);
      }
      
      // Highlight targeted mesh slightly while gazing
      activeChoices.forEach(child => {
          if(child.material && child.material.color) {
              const baseColor = child.userData.originalColor || 0x0969da;
              if (!child.userData.originalColor) child.userData.originalColor = child.material.color.getHex();
              child.material.color.setHex(child === targetMesh ? 0x3b82f6 : baseColor);
          }
      });
    }

    // === Media Generators (Upgraded for VR Readability) ===
    function clearOverlays() {
      while (overlaysGroup.children.length > 0) {
        const child = overlaysGroup.children[0];
        overlaysGroup.remove(child);
        if(child.type === 'Group') {
           child.children.forEach(c => disposeNode(c));
        } else {
           disposeNode(child);
        }
      }
      activeChoices = [];
      gazeTimer = 0;
      lastIntersectedChoice = null;
    }
    
    function disposeNode(child) {
        if (child.geometry) child.geometry.dispose();
        if (child.material) {
          if (child.material.map) child.material.map.dispose();
          child.material.dispose();
        }
    }

    function createImagePlane(url, options = {}) {
        return new Promise((resolve) => {
            const img = new Image();
            img.src = url;
            img.onload = () => {
                const aspect = img.width / img.height;
                const baseWidth = 4; 
                const scale = options.scale || 1;
                const geo = new THREE.PlaneGeometry(baseWidth * aspect * scale, baseWidth * scale);
                const tex = new THREE.Texture(img);
                tex.colorSpace = THREE.SRGBColorSpace;
                tex.needsUpdate = true;
                const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, side: THREE.DoubleSide });
                resolve(new THREE.Mesh(geo, mat));
            };
            img.onerror = () => resolve(null);
        });
    }

    // Upgraded text generator with Retina (High-DPI) support
    function createTextPlane(text, options = {}) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      const logicWidth = options.width || 512;
      const logicHeight = options.height || 128;
      const fontSize = options.fontSize || 32;
      const fontWeight = options.fontWeight || 'normal';
      
      // Scale up internal canvas resolution for sharp VR text
      const pixelRatio = 3; 
      canvas.width = logicWidth * pixelRatio;
      canvas.height = logicHeight * pixelRatio;
      
      ctx.scale(pixelRatio, pixelRatio);
      
      const textColor = options.textColor || 'white';
      const backgroundColor = options.backgroundColor || 'rgba(0,0,0,0.5)';
      const scale = options.scale || 1;
      const padding = 20;
      
      // Draw Background (Rounded Rectangle)
      ctx.fillStyle = backgroundColor;
      ctx.beginPath();
      const radius = 16;
      ctx.moveTo(radius, 0);
      ctx.lineTo(logicWidth - radius, 0);
      ctx.quadraticCurveTo(logicWidth, 0, logicWidth, radius);
      ctx.lineTo(logicWidth, logicHeight - radius);
      ctx.quadraticCurveTo(logicWidth, logicHeight, logicWidth - radius, logicHeight);
      ctx.lineTo(radius, logicHeight);
      ctx.quadraticCurveTo(0, logicHeight, 0, logicHeight - radius);
      ctx.lineTo(0, radius);
      ctx.quadraticCurveTo(0, 0, radius, 0);
      ctx.closePath();
      ctx.fill();
      
      // Draw Text
      ctx.fillStyle = textColor;
      ctx.font = `${fontWeight} ${fontSize}px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      const words = text.split(' ');
      let lines = [];
      let line = '';
      for(let n = 0; n < words.length; n++) {
        let testLine = line + words[n] + ' ';
        let metrics = ctx.measureText(testLine);
        if (metrics.width > logicWidth - padding * 2 && n > 0) {
          lines.push(line);
          line = words[n] + ' ';
        } else {
          line = testLine;
        }
      }
      lines.push(line);
      const lineHeight = fontSize * 1.3;
      const startY = (logicHeight - (lines.length - 1) * lineHeight) / 2;
      
      for (let i = 0; i < lines.length; i++) {
        ctx.fillText(lines[i].trim(), logicWidth / 2, startY + (i * lineHeight));
      }
      
      const texture = new THREE.CanvasTexture(canvas);
      texture.colorSpace = THREE.SRGBColorSpace;
      texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
      
      const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide });
      const geometry = new THREE.PlaneGeometry((logicWidth / 256) * scale, (logicHeight / 256) * scale);
      
      return new THREE.Mesh(geometry, material);
    }

    function updateStatus(message, isError = false) {
      statusElement.textContent = message;
      statusElement.style.display = 'block';
      statusElement.style.background = isError ? 'rgba(220, 38, 38, 0.95)' : 'rgba(17, 24, 39, 0.9)';
      setTimeout(() => { 
        statusElement.style.display = 'none'; 
      }, isError ? 5000 : 3000);
    }
    
    init();
  </script>
</body>
</html>
