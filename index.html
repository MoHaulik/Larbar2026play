<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>LærbarXR Session Player</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; 
      background: #f0f2f5; 
      color: #333;
    }
    #overlay { 
      position: absolute; 
      top: 0; 
      left: 0; 
      width: 100%; 
      height: 100%; 
      display: flex; 
      flex-direction: column; 
      justify-content: center; 
      align-items: center; 
      z-index: 9000;
      padding: 20px;
      box-sizing: border-box;
      text-align: center;
    }
    .card {
      background: rgba(255,255,255,0.95);
      border-radius: 16px;
      padding: 24px 32px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.1);
      max-width: 400px;
      width: 100%;
    }
    h1 {
      margin-top: 0;
      font-size: 24px;
      color: #000;
    }
    #file-select { 
      display: inline-block;
      padding: 14px 28px; 
      font-size: 16px; 
      background: #007aff; 
      color: white; 
      border: none; 
      border-radius: 12px; 
      box-shadow: 0 4px 12px rgba(0,122,255,0.2); 
      cursor: pointer; 
      transition: all 0.2s; 
      font-weight: 600;
      margin-bottom: 20px;
    }
    #file-select:hover { 
      transform: translateY(-2px); 
      background: #006ae0;
      box-shadow: 0 6px 16px rgba(0,122,255,0.3); 
    }
    #file-input { display: none; }
    
    #session-info {
      font-size: 16px;
      color: #555;
      margin-bottom: 24px;
      font-weight: 500;
      min-height: 24px;
    }

    #join-code-section {
      display: none; 
      margin: 20px 0;
      border-top: 1px solid #e0e0e0;
      padding-top: 20px;
    }

    #join-code-input {
      width: 100%;
      padding: 12px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      font-size: 32px;
      font-weight: 700;
      color: #007aff;
      letter-spacing: 5px;
      text-align: center;
      border: 2px solid #ddd;
      border-radius: 8px;
      box-sizing: border-box;
      text-transform: uppercase;
      margin-bottom: 15px; 
    }
    #join-code-input::placeholder {
      color: #ccc;
      font-weight: 400;
      font-size: 20px;
      letter-spacing: 1px;
    }
    #join-code-input:focus {
      border-color: #007aff;
      outline: none;
    }
    #join-code-status {
      width: 32px;
      height: 32px;
      margin: 12px auto 0;
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      transition: all 0.2s;
    }
    #join-code-status.online {
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%2334C759'%3E%3Cpath d='M11 21.0354C11.4142 21.0354 11.75 20.6996 11.75 20.2854V12.0354H14.463C14.9026 12.0354 15.1229 11.5302 14.8217 11.1969L8.45514 3.96148C8.17961 3.65544 7.72759 3.8641 7.72759 4.28848V12.0354H5.03702C4.59738 12.0354 4.37706 12.5407 4.67828 12.8739L11.0449 20.1093C11.3204 20.4154 11.7724 20.2067 11.7724 19.7823V12.0354H11V21.0354Z'/%3E%3C/svg%3E");
      transform: scale(1.1);
    }

    #start-button { 
      padding: 15px 28px; 
      font-size: 18px; 
      background: #34c759; 
      color: white; 
      border: none; 
      border-radius: 12px; 
      box-shadow: 0 4px 12px rgba(52,199,89,0.2); 
      cursor: pointer; 
      transition: all 0.2s; 
      font-weight: 600;
      width: 100%;
      margin-top: 10px;
    }
    #start-button:hover { 
      transform: translateY(-2px); 
      background: #2ca94c;
      box-shadow: 0 6px 16px rgba(52,199,89,0.3);
    }
    #start-button:disabled {
      background: #e0e0e0;
      color: #999;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }

    #status { 
      position: fixed; 
      bottom: 40px; 
      left: 50%; 
      transform: translateX(-50%); 
      background: rgba(0,0,0,0.7); 
      color: white; 
      padding: 12px 24px; 
      border-radius: 16px; 
      font-size: 16px; 
      font-weight: 500; 
      display: none; 
      z-index: 9999; 
      transition: opacity 0.3s;
    }
    .exit-xr { 
      position: fixed; 
      top: 20px; 
      right: 20px; 
      background: rgba(255,255,255,0.8); 
      color: black; 
      border: none; 
      border-radius: 50%; 
      width: 46px; 
      height: 46px; 
      display: none; 
      align-items: center; 
      justify-content: center; 
      font-size: 24px; 
      cursor: pointer; 
      z-index: 9999;
      font-weight: bold;
      line-height: 1;
    }
    .xr-active .exit-xr { display: flex; }
    .xr-active #overlay { display: none; }
    video { display: none; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.module.js" type="module"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</head>
<body>
  <video id="video" playsinline crossorigin="anonymous" loop></video>

  <div id="overlay">
    <div class="card">
      <h1>LærbarXR Player</h1>
      <label id="file-select" for="file-input">Upload LærbarXR Session (.zip or .lxr)</label>
      <input type="file" id="file-input" accept=".zip,.lxr">
      
      <div id="session-info">No session loaded</div>
      
      <div id="join-code-section">
        <input type="text" id="join-code-input" placeholder="Enter Join Code" maxlength="6">
        <div id="join-code-status"></div>
      </div>
      <button id="start-button" disabled>Start Session</button>
    </div>
  </div>

  <button class="exit-xr" id="exit-xr" aria-label="Exit XR">×</button>
  <div id="status"></div>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.module.js';

    let camera, scene, renderer, xrSession = null;
    let videoElement, videoTexture, videoMaterial, videoMesh;
    let sphereGeometry360;
    let raycaster, reticle, clock;
    
    let gazeTimer = 0;
    let lastIntersectedChoice = null;
    const GAZE_TIME_THRESHOLD = 2.0;
    
    let sessionData = null;
    let assetCache = {};
    let currentNode = null;
    let nodeTimer = 0;
    let activeChoices = []; 
    
    // Group holding the active Overlays (texts, images, choices) so we can fade them globally 
    let overlaysGroup = new THREE.Group();

    let isMonitoringConnected = false;
    const CORRECT_JOIN_CODE = "QJOXRL"; 

    let sessionLog = [];
    let sessionStartTime = 0;

    const startButton = document.getElementById('start-button');
    const fileInput = document.getElementById('file-input');
    const sessionInfo = document.getElementById('session-info');
    const statusElement = document.getElementById('status');
    const exitButton = document.getElementById('exit-xr');
    
    const joinCodeSection = document.getElementById('join-code-section');
    const joinCodeInput = document.getElementById('join-code-input');
    const joinCodeStatus = document.getElementById('join-code-status');

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 30);
      scene.add(camera);
      
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      renderer.setClearColor(0x000000, 1);
      document.body.appendChild(renderer.domElement);
      
      raycaster = new THREE.Raycaster();
      clock = new THREE.Clock();
      
      const reticleGeo = new THREE.RingGeometry(0.015, 0.02, 32);
      const reticleMat = new THREE.MeshBasicMaterial({ color: 0xffffff, opacity: 0.7, transparent: true, side: THREE.DoubleSide });
      reticle = new THREE.Mesh(reticleGeo, reticleMat);
      
      const gazeProgressGeo = new THREE.CircleGeometry(0.015, 32);
      const gazeProgressMat = new THREE.MeshBasicMaterial({ color: 0x007aff, opacity: 0.8, transparent: true, side: THREE.DoubleSide });
      const gazeProgress = new THREE.Mesh(gazeProgressGeo, gazeProgressMat);
      gazeProgress.name = 'gazeProgress';
      gazeProgress.scale.set(0, 0, 0);
      
      reticle.add(gazeProgress);
      reticle.position.z = -1;
      camera.add(reticle);
      
      videoElement = document.getElementById('video');
      videoTexture = new THREE.VideoTexture(videoElement);
      videoTexture.minFilter = THREE.LinearFilter;
      videoTexture.magFilter = THREE.LinearFilter;
      videoTexture.format = THREE.RGBAFormat;
      
      sphereGeometry360 = new THREE.SphereGeometry(15, 64, 32, 0, Math.PI * 2, 0, Math.PI);
      sphereGeometry360.scale(-1, 1, 1); 
      videoMaterial = new THREE.MeshBasicMaterial({ map: videoTexture, side: THREE.FrontSide });
      videoMesh = new THREE.Mesh(sphereGeometry360, videoMaterial);
      // We align 0 rotation so that mathematical mapping (yaw=0 => X=50) aligns with the video center
      videoMesh.rotation.y = 0; 
      scene.add(videoMesh);
      
      scene.add(overlaysGroup);

      window.addEventListener('resize', onWindowResize);
      startButton.addEventListener('click', startXR);
      exitButton.addEventListener('click', () => { if (xrSession) xrSession.end(); });
      fileInput.addEventListener('change', handleFileSelect);
      joinCodeInput.addEventListener('input', handleJoinCodeInput);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    async function handleFileSelect(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      sessionInfo.textContent = 'Loading session...';
      startButton.disabled = true;
      isMonitoringConnected = false;
      joinCodeSection.style.display = 'none';
      joinCodeStatus.className = '';
      joinCodeInput.value = '';
      joinCodeInput.disabled = false;
      sessionData = null;
      
      Object.keys(assetCache).forEach(url => URL.revokeObjectURL(url));
      assetCache = {};

      try {
        const zip = await JSZip.loadAsync(file);
        const projectFile = zip.file('project.json');
        
        if (projectFile) {
            // New Builder Structure (Reads standard output from Builder)
            const projectData = await projectFile.async('string');
            sessionData = JSON.parse(projectData);

            const assetPromises = [];
            if (sessionData.assets.videos) {
                sessionData.assets.videos.forEach(v => {
                    const f = zip.file(v.file);
                    if (f) assetPromises.push(f.async('blob').then(b => assetCache[v.id] = URL.createObjectURL(b)));
                });
            }
            if (sessionData.assets.images) {
                sessionData.assets.images.forEach(img => {
                    const f = zip.file(img.file);
                    if (f) assetPromises.push(f.async('blob').then(b => assetCache[img.id] = URL.createObjectURL(b)));
                });
            }
            await Promise.all(assetPromises);

        } else {
            // Fallback for Old Player Structure
            const htmlFile = zip.file('index.html');
            if (!htmlFile) throw new Error('project.json or index.html not found in zip file.');
            const htmlContent = await htmlFile.async('string');
            const flowRegex = /const\s+flow\s*=\s*(\{[\s\S]*?\});/;
            const match = htmlContent.match(flowRegex);
            if (!match || !match[1]) throw new Error('Could not parse legacy session data.');
            sessionData = (new Function(`return ${match[1]}`))();
            
            const assetsFolder = zip.folder('assets');
            const assetPromises = [];
            assetsFolder.forEach((relativePath, zipEntry) => {
                assetPromises.push(
                    zipEntry.async('blob').then(blob => {
                        const url = URL.createObjectURL(blob);
                        assetCache[zipEntry.name.split('/').pop()] = url; 
                    })
                );
            });
            await Promise.all(assetPromises);
        }

        if (!sessionData || !sessionData.nodes || !sessionData.startNode) {
            throw new Error('Session data structure is invalid.');
        }

        sessionInfo.textContent = `Loaded: ${sessionData.title}`;
        updateStatus('Session loaded successfully!');
        
        joinCodeSection.style.display = 'block';
        joinCodeInput.focus();

      } catch (err) {
        console.error('Failed to load session:', err);
        sessionInfo.textContent = 'Error loading session.';
        updateStatus(`Error: ${err.message}`, true);
        joinCodeSection.style.display = 'none';
      }
    }
    
    function handleJoinCodeInput() {
      const enteredCode = joinCodeInput.value.toUpperCase();
      if (enteredCode === CORRECT_JOIN_CODE) {
        isMonitoringConnected = true;
        joinCodeStatus.className = 'online';
        startButton.disabled = false;
        joinCodeInput.disabled = true;
        updateStatus('Monitoring connected!');
      } else {
        isMonitoringConnected = false;
        joinCodeStatus.className = '';
        startButton.disabled = true;
      }
    }
    
    function startXR() {
      if (!sessionData) { updateStatus('No session loaded.', true); return; }
      if (!isMonitoringConnected) { updateStatus('Please enter the correct join code.', true); return; }
      
      navigator.xr.requestSession('immersive-vr', {
        optionalFeatures: ['local-floor']
      })
      .then(onSessionStarted)
      .catch(err => updateStatus(`Failed to start VR: ${err.message}`, true));
    }
    
    function onSessionStarted(session) {
      xrSession = session;
      document.body.classList.add('xr-active');
      renderer.xr.setReferenceSpaceType('local');
      renderer.xr.setSession(session);
      renderer.setAnimationLoop(render);
      session.addEventListener('end', onSessionEnd);
      
      sessionStartTime = performance.now();
      sessionLog = [{ action: 'session_start', title: sessionData.title, join_code: CORRECT_JOIN_CODE, timestamp: sessionStartTime }];
      
      currentNode = sessionData.nodes.find(n => n.id === sessionData.startNode);
      if (currentNode) {
        loadNode(currentNode);
      } else {
        updateStatus('Error: Start node not found.', true);
        session.end();
      }
    }

    function onSessionEnd() {
      document.body.classList.remove('xr-active');
      renderer.setAnimationLoop(null);
      xrSession = null;
      videoElement.pause();
      videoElement.src = '';
      clearOverlays();
      
      if (sessionLog.length > 1) {
        sessionLog.push({ action: 'session_end', timestamp: performance.now(), total_duration_sec: (performance.now() - sessionStartTime) / 1000 });
        try {
          const reportData = JSON.stringify(sessionLog, null, 2);
          const blob = new Blob([reportData], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `${sessionData.title.replace(/[^a-z0-9]/gi, '_')}_evaluation.json`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          updateStatus('Session ended. Evaluation data downloaded.');
        } catch (err) {
          console.error('Failed to generate report:', err);
          updateStatus('Session ended. Failed to download report.', true);
        }
      }
      
      sessionLog = [];
      sessionStartTime = 0;
      currentNode = null;
      isMonitoringConnected = false;
      joinCodeSection.style.display = 'none';
      joinCodeStatus.className = '';
      joinCodeInput.value = '';
      joinCodeInput.disabled = false;
      startButton.disabled = true;
      sessionInfo.textContent = 'No session loaded';
    }
    
    async function loadNode(node) {
      console.log('Loading node:', node.title);
      sessionLog.push({ action: 'node_start', node_id: node.id, node_title: node.title, node_type: node.type, timestamp: performance.now() });
      
      clearOverlays();
      nodeTimer = 0;
      window.isTransitioning = false;

      // Handle Video
      videoElement.pause();
      videoMesh.visible = false;
      if (node.video) {
        // Resolve either by Builder ID or legacy Name
        let videoSrc = assetCache[node.video]; 
        if (!videoSrc && sessionData.assets.videos) {
            const videoAsset = sessionData.assets.videos.find(v => v.id === node.video);
            if (videoAsset) videoSrc = assetCache[videoAsset.id] || assetCache[videoAsset.name];
        }
        
        if (videoSrc) {
          videoElement.src = videoSrc;
          // Loop is disabled, we handle the 'ended' logic ourselves now to accommodate the builder
          videoElement.loop = false; 
          videoElement.play().catch(e => console.warn("Video play failed:", e));
          videoMesh.visible = true;
        } else {
          console.warn(`Video asset "${node.video}" not found in cache.`);
        }
      }

      // Handle Builder Image Overlays
      if (node.imageOverlays) {
          for (const io of node.imageOverlays) {
              if (!io.imageId || !assetCache[io.imageId]) continue;
              const mesh = await createImagePlane(assetCache[io.imageId], { scale: io.scale || 1 });
              if (mesh) {
                  positionMeshFromXY(mesh, io.x, io.y, 8);
                  mesh.userData = { startTime: io.time || 0, endTime: (io.time || 0) + (io.duration || 5), isOverlay: true };
                  mesh.visible = false; 
                  overlaysGroup.add(mesh);
              }
          }
      }

      // Handle Builder Text Overlays
      if (node.textOverlays) {
          for (const to of node.textOverlays) {
              const textMesh = createTextPlane(to.text || '', { 
                  fontSize: 48, 
                  backgroundColor: to.color || 'rgba(255, 255, 255, 0.9)', 
                  textColor: to.textColor || 'black', 
                  scale: to.scale || 1 
              });
              positionMeshFromXY(textMesh, to.x, to.y, 8);
              textMesh.userData = { startTime: to.time || 0, endTime: (to.time || 0) + (to.duration || 3), isOverlay: true };
              textMesh.visible = false;
              overlaysGroup.add(textMesh);
          }
      }

      // Handle Question & Choices
      if (node.question || (node.choices && node.choices.length > 0)) {
          const qGroup = new THREE.Group();
          let yOffset = 0;
          const scale = node.questionScale || 1;

          if (node.question) {
              const qMesh = createTextPlane(node.question, { 
                  fontSize: 56, width: 1024, height: 256, 
                  backgroundColor: 'rgba(0, 0, 0, 0.8)', textColor: 'white', 
                  fontWeight: 'bold', scale: scale 
              });
              qMesh.position.set(0, yOffset, 0);
              qGroup.add(qMesh);
              yOffset -= (0.8 * scale);
          }

          if (node.choices && node.choices.length > 0) {
              node.choices.forEach((choice, index) => {
                  const cMesh = createTextPlane(choice.label, { 
                      fontSize: 48, width: 800, height: 160, 
                      backgroundColor: 'rgba(9, 105, 218, 0.9)', textColor: 'white', 
                      scale: scale * 0.8 
                  });
                  cMesh.position.set(0, yOffset, 0);
                  cMesh.userData = { isChoice: true, choiceData: choice };
                  qGroup.add(cMesh);
                  activeChoices.push(cMesh);
                  yOffset -= (0.5 * scale);
              });
          }

          positionMeshFromXY(qGroup, node.questionX || 50, node.questionY || 50, 8);
          qGroup.userData = { startTime: node.questionTime || 0, endTime: Infinity, isOverlay: true };
          qGroup.visible = false;
          overlaysGroup.add(qGroup);
      }
    }

    // Helper to map flat UI Coordinates to 3D spherical positions
    function positionMeshFromXY(mesh, pctX, pctY, radius) {
        pctX = pctX !== undefined ? pctX : 50;
        pctY = pctY !== undefined ? pctY : 50;
        // X maps to Longitude (Yaw): 50 is center-front (0 radians), 0 is Left (-PI), 100 is Right (+PI)
        const yaw = (pctX - 50) / 100 * (Math.PI * 2); 
        // Y maps to Latitude (Pitch): 50 is Horizon (0 radians), 0 is Top (+PI/2), 100 is Bottom (-PI/2)
        const pitch = (50 - pctY) / 100 * Math.PI; 

        mesh.position.set(
            radius * Math.sin(yaw) * Math.cos(pitch),
            radius * Math.sin(pitch),
            -radius * Math.cos(yaw) * Math.cos(pitch)
        );
        mesh.lookAt(0, 0, 0); // Always face the user
    }
    
    function selectChoice(choice) {
      if(window.isTransitioning) return;
      window.isTransitioning = true;
      
      console.log('Selected choice:', choice.label);
      gazeTimer = 0;
      lastIntersectedChoice = null;
      updateGazeProgress(0);
      
      sessionLog.push({
        action: 'choice_made', node_id: currentNode.id, choice_label: choice.label,
        choice_correct: choice.correct, target_node: choice.target, timestamp: performance.now()
      });
      
      let nextNodeId = choice.target || currentNode.defaultNext;
      if (nextNodeId) {
        const nextNode = sessionData.nodes.find(n => n.id === nextNodeId);
        if (nextNode) {
          if (nextNode.type === 'end') { loadNode(nextNode); endSession(); } 
          else { currentNode = nextNode; loadNode(currentNode); }
        } else {
          console.warn(`Next node ID "${nextNodeId}" not found.`);
          endSession();
        }
      } else {
        endSession();
      }
    }
    
    function endSession() {
      if (xrSession) xrSession.end();
      else onSessionEnd();
    }

    function render(timestamp, frame) {
      const dt = clock.getDelta();
      
      let currentTime = 0;
      if (currentNode) {
          if (currentNode.video && videoElement && videoElement.readyState > 0) {
              currentTime = videoElement.currentTime;
              
              // Handle Auto-Navigate if video ended naturally without choices
              if (videoElement.ended && currentNode.defaultNext && activeChoices.length === 0) {
                  selectChoice({ label: 'auto-navigate-video-end', target: currentNode.defaultNext });
              }
          } else {
              // Time fallback for text/end nodes
              nodeTimer += dt;
              currentTime = nodeTimer;
              if (currentNode.defaultNext && activeChoices.length === 0 && currentTime >= (currentNode.duration || 10)) {
                  selectChoice({ label: 'auto-navigate-timer', target: currentNode.defaultNext });
              }
          }

          // Evaluate Overlays Visibilities
          overlaysGroup.children.forEach(child => {
              if (child.userData.isOverlay && child.userData.startTime !== undefined) {
                  const shouldBeVisible = currentTime >= child.userData.startTime && currentTime <= child.userData.endTime;
                  child.visible = shouldBeVisible;
              }
          });
      }

      handleGazeInteraction(dt);
      if (videoTexture) videoTexture.needsUpdate = true;
      renderer.render(scene, camera);
    }

    function handleGazeInteraction(dt) {
      raycaster.setFromCamera({ x: 0, y: 0 }, camera);
      
      // We only want to intersect with activeChoices that are currently visible 
      // (Their parent group's visibility rules apply)
      const visibleChoices = activeChoices.filter(c => c.visible && (c.parent ? c.parent.visible : true));
      const intersects = raycaster.intersectObjects(visibleChoices, false);
      
      let intersectedChoice = null;
      if (intersects.length > 0) {
         intersectedChoice = intersects[0].object;
      }

      if (intersectedChoice) {
        if (lastIntersectedChoice === intersectedChoice) {
          gazeTimer = Math.min(GAZE_TIME_THRESHOLD, gazeTimer + dt);
          if (gazeTimer >= GAZE_TIME_THRESHOLD) {
            selectChoice(intersectedChoice.userData.choiceData);
          }
        } else {
          gazeTimer = 0;
          lastIntersectedChoice = intersectedChoice;
        }
        updateGazeProgress(gazeTimer / GAZE_TIME_THRESHOLD, intersectedChoice);
      } else {
        gazeTimer = 0;
        lastIntersectedChoice = null;
        updateGazeProgress(0);
      }
    }

    function updateGazeProgress(progress, targetMesh = null) {
      const progressIndicator = reticle.getObjectByName('gazeProgress');
      if (progressIndicator) {
        const scale = Math.max(0, Math.min(1, progress));
        progressIndicator.scale.set(scale, scale, scale);
      }
      activeChoices.forEach(child => {
          // Adjust choice background hover color safely
          if(child.material && child.material.color) {
              const originalColor = child.userData.originalColor || 0x0969da;
              if (!child.userData.originalColor) child.userData.originalColor = child.material.color.getHex();
              child.material.color.setHex(child === targetMesh ? 0x00A0FF : originalColor);
          }
      });
    }

    // --- Media Generators ---

    function clearOverlays() {
      while (overlaysGroup.children.length > 0) {
        const child = overlaysGroup.children[0];
        overlaysGroup.remove(child);
        if(child.type === 'Group') {
           child.children.forEach(c => disposeNode(c));
        } else {
           disposeNode(child);
        }
      }
      activeChoices = [];
      gazeTimer = 0;
      lastIntersectedChoice = null;
    }
    
    function disposeNode(child) {
        if (child.geometry) child.geometry.dispose();
        if (child.material) {
          if (child.material.map) child.material.map.dispose();
          child.material.dispose();
        }
    }

    function createImagePlane(url, options = {}) {
        return new Promise((resolve) => {
            const img = new Image();
            img.src = url;
            img.onload = () => {
                const aspect = img.width / img.height;
                const baseWidth = 4; // Virtual width unit
                const scale = options.scale || 1;
                const geo = new THREE.PlaneGeometry(baseWidth * aspect * scale, baseWidth * scale);
                const tex = new THREE.Texture(img);
                tex.needsUpdate = true;
                const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, side: THREE.DoubleSide });
                resolve(new THREE.Mesh(geo, mat));
            };
            img.onerror = () => resolve(null);
        });
    }

    function createTextPlane(text, options = {}) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const width = options.width || 512;
      const height = options.height || 128;
      const fontSize = options.fontSize || 32;
      const fontWeight = options.fontWeight || 'normal';
      const textColor = options.textColor || 'white';
      const backgroundColor = options.backgroundColor || 'rgba(0,0,0,0.5)';
      const scale = options.scale || 1;
      const padding = 20;
      
      canvas.width = width;
      canvas.height = height;
      
      // Draw Background
      ctx.fillStyle = backgroundColor;
      ctx.beginPath();
      ctx.moveTo(10, 0);
      ctx.lineTo(width - 10, 0);
      ctx.quadraticCurveTo(width, 0, width, 10);
      ctx.lineTo(width, height - 10);
      ctx.quadraticCurveTo(width, height, width - 10, height);
      ctx.lineTo(10, height);
      ctx.quadraticCurveTo(0, height, 0, height - 10);
      ctx.lineTo(0, 10);
      ctx.quadraticCurveTo(0, 0, 10, 0);
      ctx.closePath();
      ctx.fill();
      
      // Draw Text
      ctx.fillStyle = textColor;
      ctx.font = `${fontWeight} ${fontSize}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const words = text.split(' ');
      let lines = [];
      let line = '';
      for(let n = 0; n < words.length; n++) {
        let testLine = line + words[n] + ' ';
        let metrics = ctx.measureText(testLine);
        let testWidth = metrics.width;
        if (testWidth > width - padding * 2 && n > 0) {
          lines.push(line);
          line = words[n] + ' ';
        } else {
          line = testLine;
        }
      }
      lines.push(line);
      const lineHeight = fontSize * 1.2;
      const startY = (height - (lines.length - 1) * lineHeight) / 2;
      for (let i = 0; i < lines.length; i++) {
        ctx.fillText(lines[i].trim(), width / 2, startY + (i * lineHeight) - (fontSize / 10));
      }
      
      const texture = new THREE.CanvasTexture(canvas);
      const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide });
      // Scale standard mesh appropriately based on builder settings
      const geometry = new THREE.PlaneGeometry((width / 256) * scale, (height / 256) * scale);
      const mesh = new THREE.Mesh(geometry, material);
      return mesh;
    }

    function updateStatus(message, isError = false) {
      statusElement.textContent = message;
      statusElement.style.display = 'block';
      statusElement.style.background = isError ? 'rgba(255, 59, 48, 0.8)' : 'rgba(0,0,0,0.7)';
      setTimeout(() => { 
        statusElement.style.display = 'none'; 
      }, isError ? 5000 : 3000);
    }
    
    init();
  </script>
</body>
</html>
